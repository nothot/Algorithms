
# 拓扑排序

拓扑排序并非一种数据排序的方式，而是生成一种有序的拓扑结构序列。
以课程网络为例，学习数据结构需要先学C++程序设计，学操作系统需要先学计算机组成，数据结构，像这样的，每门课程都会有若干门前驱课程，所有课程形成一张拓扑网络。
拓扑排序旨在生成一个序列，在序列中任何一个节点，沿着序列向后走，不会走到它的前驱节点，换句话说，对序列中任一节点，其所有前驱节点都在它前面，这样一种序列称为拓扑序列

# 最小生成树

在图网络中，生成一颗连通所有节点，无环，且代价最小的树

## Kruskal算法

算法思想：（加边法）
1. 对所有包含权值的边从小到大排序
2. 从当前边序列中挑出值最小的边，如果边的两个顶点已在当前生成树中，舍弃，否则，将边加入生成树中
3. 重复步骤2，直至生成树顶点数达到图顶点数或边序列遍历完毕

## Prim算法

算法思想：（加点法）
1. 任取一顶点加入生成树的顶点集V，生成所有不在V中的顶点到V（当前只有一个顶点）的边权值集合S
2. 取S中最小边对应的顶点加入V中，更新所有不在V中的顶点到V的边权值集合S
3. 重复步骤2，直至图所有顶点已加入V中

> 第2步中更新边权值集合S时，只需要对任一不在V中的顶点，比较S中已记录的权值和该顶点与新加入的顶点构成的边权值的大小，S中保留两者最小值

# 最短路径

## Dijkstra算法

算法思想：
定义三个数组，待检查顶点集V，顶点到起始点的最短路径集S，顶点的父节点集P (记录顶点是从哪个节点过来的)
1. 将给定点作为起始点，加入待检查点集V
2. 从V中输出并移除一个具有最小距离的点x（距起始点的距离，从S中查询）
3. 将点x可到达的所有点加入V中，如果点不在V中，加入并更新S，P，如果点在V中已存在，比较该点经过x的最短路径和V中已存在的该点的最短路径大小，更小则取代，更新S，P，否则，舍弃该点
4. 重复步骤2和3，直至V中已没有顶点

> 该方法从给定点出发，不断向外扩散，寻找到周围点的最短路径，直至将图所有点扩散完毕，则计算出了该点到任一点的最短路径

## Floyd算法

算法思想：
定义一个二维数组D，D[i][j]表示点i与点j的最短距离
点i与点j的最短距离共有两种情况：
1. 点i与点j直接的距离
2. 点i与点j经过某些点中转的距离
基于此，可给出算法
依次遍历图的每一个顶点
1. 计算任意两点i，j经过顶点1中转的最短距离
2. 计算任意两点i，j经过顶点2中转的最短距离，更新D（此时已经计算过顶点1中转的情况，D[i][j]可能是直达距离，也可能是若干点中转后的距离）
3. 计算任意两点i，j经过顶点3中转的最短距离，更新D
p. ...
k. 计算任意两点i，j经过顶点k中转的最短距离，更新D
q. ...
N. 计算任意两点i，j经过顶点N中转的最短距离，更新D（所有顶点作为中转点都遍历完毕，D中已经计算出了任意两点的最短距离）

> 此算法即为动态规划，可使用二维DP（i，j）或三维DP（i，j，k)来描述
